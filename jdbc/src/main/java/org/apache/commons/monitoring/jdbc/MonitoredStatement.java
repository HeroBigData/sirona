/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.monitoring.jdbc;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import org.apache.commons.monitoring.Monitor;
import org.apache.commons.monitoring.Repository;
import org.apache.commons.monitoring.StopWatch;

/**
 * @author <a href="mailto:ndeloof@sourceforge.net">Nicolas De Loof</a>
 */
public class MonitoredStatement
    implements Statement
{
    /** delegate statement */
    private Statement statement;

    protected Repository repository;

    public MonitoredStatement( Statement statement, Repository repository )
    {
        super();
        this.statement = statement;
        this.repository = repository;
    }

    protected SQLException monitor( SQLException sqle )
    {
        String name = "SQLException:" + sqle.getSQLState() + ":" + sqle.getErrorCode();
        Monitor monitor = repository.getMonitor( name, "jdbc" );
        monitor.getCounter( Monitor.FAILURES ).add( 1 );
        return sqle;
    }

    // --- delegate methods ---

    public final void addBatch( String sql )
        throws SQLException
    {
        statement.addBatch( sql );
    }

    public final void cancel()
        throws SQLException
    {
        statement.cancel();
    }

    public final void clearBatch()
        throws SQLException
    {
        statement.clearBatch();
    }

    public final void clearWarnings()
        throws SQLException
    {
        statement.clearWarnings();
    }

    public final void close()
        throws SQLException
    {
        statement.close();
    }

    public final boolean execute( String sql, int autoGeneratedKeys )
        throws SQLException
    {
        StopWatch stopWatch = repository.start( repository.getMonitor( sql, "jdbc" ) );
        try
        {
            return statement.execute( sql, autoGeneratedKeys );
        }
        catch ( SQLException sqle )
        {
            throw monitor( sqle );
        }
        finally
        {
            stopWatch.stop();
        }
    }

    public final boolean execute( String sql, int[] columnIndexes )
        throws SQLException
    {
        StopWatch stopWatch = repository.start( repository.getMonitor( sql, "jdbc" ) );
        try
        {
            return statement.execute( sql, columnIndexes );
        }
        catch ( SQLException sqle )
        {
            throw monitor( sqle );
        }
        finally
        {
            stopWatch.stop();
        }
    }

    public final boolean execute( String sql, String[] columnNames )
        throws SQLException
    {
        StopWatch stopWatch = repository.start( repository.getMonitor( sql, "jdbc" ) );
        try
        {
            return statement.execute( sql, columnNames );
        }
        catch ( SQLException sqle )
        {
            throw monitor( sqle );
        }
        finally
        {
            stopWatch.stop();
        }
    }

    public final boolean execute( String sql )
        throws SQLException
    {
        StopWatch stopWatch = repository.start( repository.getMonitor( sql, "jdbc" ) );
        try
        {
            return statement.execute( sql );
        }
        catch ( SQLException sqle )
        {
            throw monitor( sqle );
        }
        finally
        {
            stopWatch.stop();
        }
    }

    public final int[] executeBatch()
        throws SQLException
    {
        StopWatch stopWatch = repository.start( repository.getMonitor( "batch", "jdbc" ) );
        try
        {
            return statement.executeBatch();
        }
        catch ( SQLException sqle )
        {
            throw monitor( sqle );
        }
        finally
        {
            stopWatch.stop();
        }
    }

    public final ResultSet executeQuery( String sql )
        throws SQLException
    {
        StopWatch stopWatch = repository.start( repository.getMonitor( sql, "jdbc" ) );
        try
        {
            return statement.executeQuery( sql );
        }
        catch ( SQLException sqle )
        {
            throw monitor( sqle );
        }
        finally
        {
            stopWatch.stop();
        }
    }

    public final int executeUpdate( String sql, int autoGeneratedKeys )
        throws SQLException
    {
        StopWatch stopWatch = repository.start( repository.getMonitor( sql, "jdbc" ) );
        try
        {
            return statement.executeUpdate( sql, autoGeneratedKeys );
        }
        catch ( SQLException sqle )
        {
            throw monitor( sqle );
        }
        finally
        {
            stopWatch.stop();
        }
    }

    public final int executeUpdate( String sql, int[] columnIndexes )
        throws SQLException
    {
        StopWatch stopWatch = repository.start( repository.getMonitor( sql, "jdbc" ) );
        try
        {
            return statement.executeUpdate( sql, columnIndexes );
        }
        catch ( SQLException sqle )
        {
            throw monitor( sqle );
        }
        finally
        {
            stopWatch.stop();
        }
    }

    public final int executeUpdate( String sql, String[] columnNames )
        throws SQLException
    {
        StopWatch stopWatch = repository.start( repository.getMonitor( sql, "jdbc" ) );
        try
        {
            return statement.executeUpdate( sql, columnNames );
        }
        catch ( SQLException sqle )
        {
            throw monitor( sqle );
        }
        finally
        {
            stopWatch.stop();
        }
    }

    public final int executeUpdate( String sql )
        throws SQLException
    {
        StopWatch stopWatch = repository.start( repository.getMonitor( sql, "jdbc" ) );
        try
        {
            return statement.executeUpdate( sql );
        }
        catch ( SQLException sqle )
        {
            throw monitor( sqle );
        }
        finally
        {
            stopWatch.stop();
        }
    }

    public final Connection getConnection()
        throws SQLException
    {
        return statement.getConnection();
    }

    public final int getFetchDirection()
        throws SQLException
    {
        return statement.getFetchDirection();
    }

    public final int getFetchSize()
        throws SQLException
    {
        return statement.getFetchSize();
    }

    public final ResultSet getGeneratedKeys()
        throws SQLException
    {
        return statement.getGeneratedKeys();
    }

    public final int getMaxFieldSize()
        throws SQLException
    {
        return statement.getMaxFieldSize();
    }

    public final int getMaxRows()
        throws SQLException
    {
        return statement.getMaxRows();
    }

    public final boolean getMoreResults()
        throws SQLException
    {
        return statement.getMoreResults();
    }

    public final boolean getMoreResults( int current )
        throws SQLException
    {
        return statement.getMoreResults( current );
    }

    public final int getQueryTimeout()
        throws SQLException
    {
        return statement.getQueryTimeout();
    }

    public final ResultSet getResultSet()
        throws SQLException
    {
        return statement.getResultSet();
    }

    public final int getResultSetConcurrency()
        throws SQLException
    {
        return statement.getResultSetConcurrency();
    }

    public final int getResultSetHoldability()
        throws SQLException
    {
        return statement.getResultSetHoldability();
    }

    public final int getResultSetType()
        throws SQLException
    {
        return statement.getResultSetType();
    }

    public final int getUpdateCount()
        throws SQLException
    {
        return statement.getUpdateCount();
    }

    public final SQLWarning getWarnings()
        throws SQLException
    {
        return statement.getWarnings();
    }

    public final void setCursorName( String name )
        throws SQLException
    {
        statement.setCursorName( name );
    }

    public final void setEscapeProcessing( boolean enable )
        throws SQLException
    {
        statement.setEscapeProcessing( enable );
    }

    public final void setFetchDirection( int direction )
        throws SQLException
    {
        statement.setFetchDirection( direction );
    }

    public final void setFetchSize( int rows )
        throws SQLException
    {
        statement.setFetchSize( rows );
    }

    public final void setMaxFieldSize( int max )
        throws SQLException
    {
        statement.setMaxFieldSize( max );
    }

    public final void setMaxRows( int max )
        throws SQLException
    {
        statement.setMaxRows( max );
    }

    public final void setQueryTimeout( int seconds )
        throws SQLException
    {
        statement.setQueryTimeout( seconds );
    }

    // --- jdbc4 ----

    public final boolean isClosed()
        throws SQLException
    {
        return statement.isClosed();
    }

    public final boolean isPoolable()
        throws SQLException
    {
        return statement.isPoolable();
    }

    public final boolean isWrapperFor( Class<?> iface )
        throws SQLException
    {
        return statement.isWrapperFor( iface );
    }

    public final void setPoolable( boolean poolable )
        throws SQLException
    {
        statement.setPoolable( poolable );
    }

    public final <T> T unwrap( Class<T> iface )
        throws SQLException
    {
        return statement.unwrap( iface );
    }
}
