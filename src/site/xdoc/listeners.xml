<?xml version="1.0"?>
<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<document>

<properties>
    <title>Monitoring listeners</title>
  </properties>

  <body>
    <section name="Listeners">
      <p>
        In many case, the application itself can take advantage of the monitoring infrastructure either
        to adapt it's behavior or to compute finest state to expose.
      </p>
      <p>
        For example, the application can switch between two implementations of a component depending
        on the business process load. A monitor that computes this load can be used by the application to
        detect the overload and switch to a lightweight implementation. To implement this, the application
        may use the monitor and programmatically (in a <code>if then else</code> block) select the
        implementation to use. A more elegant way is to attach a Listener to the Gauge that monitors the load.
      </p>
      <p>
        Repository, Monitors and Metrics support listeners. The <code>Metric.Listener</code> interface
        allows custom code to get notified when a value is updated. This is a nice way to detect some
        value to increase abnormally and to adapt application behavior. The main advantage is that such
        listener can be reused and don't require code intrusive changes in the monitored components.
      </p>
      <p>
        <code>Monitor.Listener</code> allows the application to get evolved when a new Metric is registered
        to the monitor. The application can register new statValues (or <em>automagically</em> creates new ones
        when requested) at any moment, and this listener can be used to get notified and pre-configure the
        statValue before it gets used.
      </p>
      <p>
        <code>Repository.Listener</code> can be used by the application to get notified any time a new monitor
        instance is created, for example to register a Monitor.Listener !
      </p>
    </section>
    <section name="ExecutionStack">
      <p>
        A listener can be used to detect that a business process exceed a maximum execution time. Just counting
        such overload events is informative but don't give finest info about the context and how to improve
        application scalability.
      </p>
      <p>
        The StopWatches used to monitor execution can be registered in the <code>ExecutionStack</code> utility
        class that maintain the set of active stopWatches for the current thread. It is recommended
        to let the stopWatches register themselves and cleaning the stack by configuring the Repository to use
        <code>ExecutionStopWatch</code> StopWatch implementation.
      </p>
      <p>
        When the Listener on the business process detects some overload, it can look at the ExecutionStack
        for the most time-consuming sub-process and log contextual information of what exactly happened.
        This is really useful to detect bottlenecks and concurrency issues, as the application can
        auto-diagnostic itself JUST when the bottlenecks occurred, with execution context available.
      </p>
    </section>
    <section name="Secondary monitors">
      <p>
        Listeners are low-level hooks to observe the monitored state and the state exposed by the application.
        A higher level is provided via the <code>org.apache.commons.monitoring.listeners.SecondaryRepository</code>.
        Secondary repositories are used to observe the monitored state for a period of time, where Listeners
        are used to observe individual monitoring events.
      </p>
      <p>
        When a SecondaryRepository is created, it registers all the required listeners to maintain a set
        or secondary monitors / counters / gauges in sync with the "primary" repository.
        A secondary gauge will share the initial state of the primary gauge. A secondary counter will start
        with initial value set to 0. The secondary repository can so be used to monitor the application during
        a period as if monitoring had just been reseted. It can then be detached from the primary repository,
        and will then not get notified anymore on application monitoring events.
      </p>
      <p>
       Secondary repositories are the first-class component for building a time-based monitoring console. See
       reporting section for more information on there usage for this use case.
      </p>
    </section>

  </body>

</document>
