<?xml version="1.0"?>
<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<document>

<properties>
    <title>Commons Monitoring tutorial</title>
  </properties>

  <body>

    <section name="Quick introduction">
      <p>
        The <b>Monitoring</b> class is a convenience utility class to make application instrumentation
        as simple as possible. To monitor application performance, simply do :
        <pre>
        public void myMethodToGetMonitored()
        {
            StopWatch stopWatch = Monitoring.start( "MyClass.myMethod" );
            try
            {
                // Do something that takes time and requires monitoring
            }
            finally
            {
                stopWatch.stop();
            }
        }
        </pre>
        The StopWatch class will compute the time elapsed during code execution and report it to the
        monitor "MyClass.myMethod".
      </p>
    </section>
    <section name="Instrumentation">
      <p>
        A <b>Monitor</b> defines a control point in the application. It can be associated to a resource,
        a code fragment or anything relevant for the application. The monitor is unique and retrieved from
        a <b>Repository</b>. It is identified by a name, a category (technical description of the application
        component) and a subsystem (functional description). In the previous code sample, only a name was set
        as category and subsystem are optional. We recommend to use them to create monitors as this is a
        convenient and powerfull way to group and sort monitors and associated statistics.
      </p>
      <p>
        The monitor maintains a set of Metrics, that can be either <b>Counters</b> or <b>Gauges</b>.
        <ul>
          <li>A Counter will get incremented any time the application does its work and expose the result to
          the monitoring backbone : byte received, lines processed...</li>
          <li>A Gauge allows the application to expose how a resource is used : active connections...</li>
        </ul>
        Each Metric is identified by a ROLE in the monitor. Default roles are defined for PERFORMANCES and
        CONCURRENCY (threads running same code), and you can register Counters/Gauges for custom roles to monitor
        anything that is relevant for your application (bytes processed, message payload, account balance ...)  :
        <pre>
            Monitor monitor = repository.getMonitor( "SoapEndpoint.process", "soap" );

            // Process a SOAP message
            monitor.getCounter( "bytes" ).add( SOAPMessage.getSize() );
        </pre>
      </p>
      <p>
        Commons Monitoring provides Helpers to instrument application, for example to monitor web application
        Request or JDBC operations, so that in many case you don't have to know commons-monitoring API to
        get basic instrumentation on your application.
      </p>
    </section>
    <section name="Repporting">
      <p>
        You can retrieve statistical datas from your monitors and Metrics to build reports. You can
        programatically acces the repository and iterate on monitors to build a custom output, or rely
        on Commons Monitoring provided <b>Renderers</b> that support common output formats (XML, TXT, JSON).
      </p>
      <p>
        When used in a webapp, Commons Monitoring provides a simple web UI.
        TODO...
      </p>
    </section>

  </body>

</document>
