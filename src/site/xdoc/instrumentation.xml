<?xml version="1.0"?>
<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<document>

  <properties>
    <title>Instrumentation of the monitored application</title>
  </properties>

  <body>

    <section name="Introduction">
      <p>
        Before anything can be reported, the application have to expose it's state to the monitoring
        infrastructure. In Commons Monitoring vocabulary this is called
        <b>instrumentation</b>
        of the
        application. Commons Monitoring defines a simple lightweight API for this purpose.
      </p>
    </section>

    <section name="Concepts">
      <subsection name="Monitors">
        <p>
          The application exposes it's state based on<b>monitors</b>. A monitor is an abstraction for any
          element in the application that can expose state or resource consumption. This can be a code
          fragment, a web application URI, a JDBC query, some business object data, etc. It is identified
          by :
          <ul>
            <li>a
              <b>name</b>
              that is the human readable representation of the exposed state
            </li>
            <li>a
              <b>category</b>
              that matches technical layering of the application
              ("web", "model", "dao"...)
            </li>
            <li>a
              <b>subsystem</b>
              that associate the monitor to a functional subsystem in the application
              ("admin", "accounts management" ...)
            </li>
          </ul>
        </p>
        <p>
          Only the name is required, but category and subsystem is a nice way to group monitors by technical
          or functional criteria.
        </p>
      </subsection>
      <subsection name="Repository">
        <p>
          Monitors are registered in a repository, that ensure a monitor is unique for a name/category/subsytem
          Key. The repository is used to retrieve existing monitors and create new ones. The
          <a href="xref/org/apache/commons/monitoring/impl/repositories/DefaultRepository">default repository
            implementation
          </a>
          creates new Monitor instance when a non-existing one is requested, so you don't have to wory
          about monitors management.
          <pre>
            Monitor monitor = repository.getMonitor( "MyService.myMethod" );
            Monitor monitor = repository.getMonitor( "SoapEndpoint.process", "soap" );
            Monitor monitor = repository.getMonitor( "/admin/userEdit.do", "struts", "user management" );
          </pre>
          You can use a custom repository by extending one of the provided implementations. You can also
          use the
          <code>ConfigurableImplementationsRepository</code>
          implementation, when you only want to configure
          custom implementation classes for StopWatches and Monitors.
        </p>
      </subsection>
      <subsection name="Counters and Gauges">
        <p>
          Monitors manage a set of
          <code>Metrics</code>
          that the application uses to expose state. The
          monitor only identifies where the data comes from, and the statValues handle the monitored data.
          There is two types of values that application can use, depending on the data to be exposed :
          <ul>
            <li>a
              <b>Counter</b>
              is used to expose cumulative events. The value a counter maintains
              will grow during the application life : time elapsed by some code to execute, number of bytes or
              lines proceeded by a batch process, number of requests on a web URI...
              <br/>
              A counter is used by application using the
              <code>add()</code>
              method
              to expose how the counter must increment when some operation have proceeded.
            </li>
            <li>a
              <b>Gauge</b>
              is used to expose an internal state that increases and decreases
              during application life : concurrent threads, open connections, active users...
              <br/>
              A gauge is used by the application using the
              <code>incremenet()</code>
              and
              <code>decrement()</code>
              methods to expose the application state changes. The
              <code>set()</code>
              method can also be used to
              force an initial value or to expose an absolute value when the application does not compute it's state
              as a change from a previous value. Typically, a
              <code>connectionManager</code>
              component will use
              increment/decrement to expose active connections, and a
              <code>fileSystemMonitor</code>
              will use
              set to expose free space on disks.
            </li>
          </ul>
        </p>
        <p>
          In both cases, the statValues compute statistical information from what the application exposes, like
          min / max / mean and standard deviation, that in many case is more informative than the current value.
          Available statistical indicators are limited as a Metric does not maintain all the individual
          elements as a serie but only aggregates, to avoid memory over-consumption.
        </p>
        <p>The
          <a href="xref/org/apache/commons/monitoring/impl/monitors/CreateValuesOnDemandMonitor">
            default monitor implementation
          </a>
          will create the required Gauge/Counters implementation when a
          statValue is requested by the application.
        </p>
      </subsection>
      <subsection name="Role">
        <p>
          A monitor can handle many statValues. Metrics are identified in a monitor by a role, that
          describes the data beeing computed. There is predefined roles for performances, concurrency
          monitoring and failures count, but any other relevant counter/gauge can be registered to a monitor.
          <pre>
            final static Role BYTES = new Role( "bytes", Unit.BYTES, Counter.class );

            static Monitor monitor = repository.getMonitor( "SoapEndpoint.process" );
            static Counter bytes = monitor.getCounter( BYTES );

            public void process( SOAPMessage message )
            {
            // Process a SOAP message

            // retrieve the custom Counter for the "byte" role
            bytes.add( SOAPMessage.getSize(), Unit.BYTES );
            }
          </pre>
          A role can be considered as a statValue prototype. It defines :
          <ul>
            <li>The name of the statValue inside the monitor</li>
            <li>The unit used for data gathered by the statValue</li>
            <li>The statValue type, beeing either
              <code>Counter.class</code>
              or
              <code>Gauge.class</code>
            </li>
          </ul>
        </p>
      </subsection>
      <subsection name="Units">
        <p>Counters and Gauge knows the data type they hold, based on the Role used to create them :
          Any data set/addition is checked for unit to be compatible. "compatible" means the passed values can be
          converted to the same primary unit, "primary" beeing the finest unit available for a data type.
          For example,<code>Unit.SECONDS</code>, is compatible with
          <code>Unit.MILLIS</code>
          as they share the same primary unit<code>Unit.NANOS</code>.
        </p>
        <p>
          You can define your own units on the same basis, to ensure good usage of your monitors
          and cleaner reporting. You can also pass data to a statValue with any compatible Unit, as
          the statValue will internally handle any required conversion.
        </p>
      </subsection>
      <subsection name="StopWatches">
        <p>Performance monitoring is first-class use case of Commons Monitoring. The
          <code>org.apache.commons.monitoring.stopwatches.StopWatch</code>
          class provides the necessary tooling
          to compute and monitor code or service invocation performances. A StopWatch is created
          by the repository for a monitor. The stopwatch is initialy "started", and will compute
          elapsed time until it is stopped by the application. The application MUST ALLWAYS stop
          the StopWatches it has created ! To ensure this, always use a finally block :
          <pre>
            StopWatch stopWatch = repository.start( myMonitor );
            try
            {
            // Do something that takes time and requires monitoring
            }
            finally
            {
            stopWatch.stop();
            }
          </pre>
        </p>
        <p>
          You can nest stopWatches, in many case by monitoring some high-level process (for example web
          request rendering time) and nested low-level service (remote service invocation, JDBC request...).
          The monitor maintains statistics about those informations as the PERFORMANCE and RESPONSE_TIME
          counters. First one only computes performance of the target code, not sub-processes.
        </p>
        <p>
          The
          <a href="xref/org/apache/commons/monitoring/impl/stopwatches/DefaultStopWatch">default StopWatch
            implementation
          </a>
          can be extended to support some custom features.
          <code>ExecutionStopWatch</code>
          for example adds support for
          a list of all stopwatches beeing used in the current thread, so that you can trace the activity if you
          detect bad performances of the global process. To use a custom StopWatch class, simply setup the
          repository using<code>new DefaultRepository( MyCustomStopWatch.class )</code>.
        </p>
      </subsection>
    </section>

    <section name="Helpers">
      <p>
        The
        <b>Monitoring</b>
        class is a convenience utility class to make application instrumentation
        as simple as possible. To monitor application performance, simply do :
        <pre>
          public void myMethodToGetMonitored()
          {
          StopWatch stopWatch = Monitoring.start( "MyClass.myMethod" );
          try
          {
          // Do something that takes time and requires monitoring
          }
          finally
          {
          stopWatch.stop();
          }
          }
        </pre>
        The StopWatch class will compute the time elapsed during code execution and report it to the
        monitor "MyClass.myMethod".
      </p>
      <p>
        Other helper classes are provided for simplier use with commons frameworks. The
        <code>org.apache.commons.monitoring.aop</code>
        package contains for example classes for use with
        AOP frameworks to automagically instrument application components.
      </p>
    </section>

  </body>

</document>
